package com.example.wendigo;

import android.content.ContentValues;
import android.content.Context;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.database.sqlite.SQLiteOpenHelper;
import android.util.Log;

public class TasksDatabaseHandler extends SQLiteOpenHelper {

    private String TAG = "DEBUG";

    public static String TASK = "task";
    public static String STATUS = "status";

    // It will always be 0, as when we insert a task, it was not done yet.
    public int TASK_STATUS = 0;


    // DB name, not using, DB version, every time a new version is created the db is recreated.
    public TasksDatabaseHandler(Context context) {
        super(context, "tasksDb", null, 60);
    }

    // Creating tables for DB
    // Only 2 fields, Task Name, Task status + row ID. Generated by autoincrement
    @Override
    public void onCreate(SQLiteDatabase db) {
        String CREATE_CONTACTS_TABLE = "CREATE TABLE tasks( _id INTEGER PRIMARY KEY AUTOINCREMENT,"
                + TASK + " TEXT, " + STATUS + " TEXT)";
        db.execSQL(CREATE_CONTACTS_TABLE);
    }

    // Update database, if new version is found, recreate a table.
    // Data will be lost, need to save the data.
    @Override
    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
        // Drop the older table if existed
        db.execSQL("DROP TABLE IF EXISTS tasks");
        // Create tables again
        onCreate(db);
    }

    // add the new task
    void addTask(Task task) {
        SQLiteDatabase db = this.getWritableDatabase();

        try {
            ContentValues values = new ContentValues();
            // Task
            values.put("task", task.getTask());
            // Task status
            values.put("status", task.getStatus());

            // Inserting Row, values are the values got from x.getName above
            db.insert("tasks", null, values);
            //2nd argument is String containing nullColumnHack
            db.close(); // Closing database connection

        } catch (Exception e) {
            Log.i(TAG, "addTask: " + e.toString());
        }


    }


    // DO I need it???
    // code to get a single task
    Task getTask(int id) {
        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.query("tasks", new String[]{"id",
                        "name", "status"}, "id" + "=?",
                new String[]{String.valueOf(id)}, null, null, null, null);
        if (cursor != null)
            cursor.moveToFirst();

        Task task = new Task(
                cursor.getString(1), cursor.getString(2));
        // return task
        return task;
    }


    // code to get all tasks in a list view
    public Cursor getAllTasks() {
        // Select All Query
        String selectQuery = "SELECT  * FROM  tasks ORDER BY status ASC;";

        SQLiteDatabase db = this.getWritableDatabase();
        Cursor taskList = db.rawQuery(selectQuery, null);

        return taskList;
    }

    // code to update the single task
    void taskUpdate(Task task) {
        SQLiteDatabase db = this.getWritableDatabase();
        ContentValues values = new ContentValues();

        if (task.getStatus().equals("1")) {
            Log.i(TAG, "UPDATE STATUS");
            values.put("status", task.getStatus());
        } else {
            Log.i(TAG, "UPDATE NOOOOOOT STATUS");
            values.put("task", task.getTask());
        }

        // updating row
        try {
            Log.i(TAG, "taskUpdate: " + task.getTask() + "-" + task.getStatus() + " -- " + task.getID());
            db.update("tasks", values, "_id" + " = ?",
                    new String[]{String.valueOf(task.getID())});
        } catch (Exception e) {
            Log.i(TAG, "Exception: " + e.toString());
        }
    }


    // Deleting single task
    public String deleteTask(Task task) {
        Log.i(TAG, "Before All: " + task.toString());
        try {
            SQLiteDatabase db = this.getWritableDatabase();
            db.delete("tasks", "_id" + " = ?",
                    new String[]{String.valueOf(task.getID())});
            db.close();
        } catch (Exception e) {
            Log.i(TAG, "deleteTask: " + e.toString());
        }
        return "wft";
    }

    // Getting tasks Count
    public int getTasksCount() {
        String countQuery = "SELECT  * FROM " + "tasks";
        SQLiteDatabase db = this.getReadableDatabase();
        Cursor cursor = db.rawQuery(countQuery, null);
        cursor.close();

        // return count
        return cursor.getCount();
    }
}